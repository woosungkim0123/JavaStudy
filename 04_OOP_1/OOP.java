public class OOP {
    public static void main(String[] args) {
        // 객체지향언어(Object Oriented Programing) = 프로그래밍 언어 + 객체지향개념(규칙)

        // 코드 재사용성 높음, 유지보수 용이, 중복코드 제거
        // 4가지 특징 : 캡슐화, 상속, 추상화, 다형성(제일 중요)

        // 클래스
        // 정의 : 객체를 정의해 놓은 것
        // 용도 : 객체를 생성하는데 사용

        // 객체
        // 정의 : 실제로 존재하는 것. 사물 또는 개념
        // 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

        // 클래스 : 제품설계도(TV 설계도), 객체 : 제품(TV)
        // TV는 왜 만듬? 사용하려고 TV설계도는 왜 만듬? TV설계도를 한번 만들어두면 TV를 쉽게 만들 수 있음

        // 객체지향 : 실제 세계(world)를 어떻게 컴퓨터 안에 옮겨 놓을까를 고민하다 나온 개념
        // HW(하드웨어(실제 세계))를 SW(소프트웨어)화 하기 위한 개념

        // 객체 = 속성(변수) + 기능(메서드)
        // 속성 : 크기, 길이, 높이 ,색상, 볼륨 등
        // 기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기 등

        // TV 설계도
        class Tv {
            String color;
            boolean power;
            int channel;

            void power() { power = !power; }
            void channelUp() { channel++; }
            void channelDown() { channel--; }
        }

        // 객체와 인스턴스 (둘 다 거의 비슷한 용어)
        // 객체 : 모든 인스턴스를 대표하는 일반적 용어
        // 인스턴스 : 특정 클래스로부터 생성된 객체(예 : TV 인스턴스)
        // TV 클래스로 부터 만들어진 객체를 TV 인스턴스라고 함

        // 클래스 (설계도도) --- 인턴스화 ---> 인스턴스(객체) (제품)
        // 클래스(설계도)를 만들었으면 따로 인스턴스(제품)을 만들어야 사용할 수 있다는 점

        // 정리
        // 1. 클래스(설계도)가 왜 필요한가? 객체(제품)를 생성하기 위해서
        // 2. 객체(제품)가 필요한 이유? 사용하려고
        // 3. 객체를 사용한다는 것은? 객체가 가진 속성과 기능을 사용하기위해해

        // 일반적으로 하나의 소스파일에 하나의 클래스만 작성하는 것이 보통통
        // 하나의 소스파일에 여러 클래스 작성할 수도 있음
        // Hello.java 파일이 있는데 거기 class Hello2와 class Hello3가 있다.
        // public 클래스가 있는 경우 public 클래스 이름과 파일이름이 일치해야함
        // public 클래스가 없는 경우 소스 파일의 이름은 Hello2.java, Hello3.java 둘다 가능하다
        // 하나의 소스파일에 둘 이상의 public 클래스가 존재하면 안된다.

        Tv a; // 참조변수(리모콘), TV 클래스 타입의 참조변수 t를 선언
        a = new Tv(); // TV 인스턴스 생성 후 생성된 TV 인스턴스의 주소를 t에 저장
        Tv b = new Tv(); // 한 문장으로 가능
        b.channel = 7;
        b.channelUp(); // 참조변수가 가리키는 메서드를 호출(메서드 사용)
        System.out.println("현재 채널은 " + b.channel + " 입니다.");

        // Tv(참조형 타입) b(변수)= new Tv();
        // 객체가 만들어지면 메모리 어딘가에 만들어지는데 그 주소를 변수에 넣은 것
        // = 대입 : Tv와 리모콘을 연결. 참조변수와 객체가 연결되어 있는 것을 화살표로 표현함

        // t = 메모리주소(0x100)  ----> 0x100
        //                          color : null
        //                          power : false
        //                          channel : 0
        //                          power()
        //                          ...

        // Tv객체를 다룰 때 반드시 t(리모콘)을 통해서만 다룰 수 있음. 리모콘 없이 객체만 다룰 수 있는 방법은 존재하지 않음
        // Tv객체니까 Tv리모콘이 필요하고 그래서 참조변수의 타입이 Tv

        // 객체를 두개 만들면 객체마다 별도의 저장공간이 생김

        // 객체 배열
        // 객체 배열 == 참조변수 배열
        Tv[] tvArr = new Tv[3];
        tvArr[0] = new Tv();
        tvArr[1] = new Tv();
        tvArr[2] = new Tv();
        // 간단히 바꾸면 Tv[] tvArr = { new Tv(), new Tv(), new Tv()};
        // 객체 배열은 단순히 참조변수 배열이기 때문에 안에 객체를 만들어서 채워넣어줘야함 (주의)

        // 클래스의 정의
        // 클래스 == 데이터 + 함수, 사용자 정의 타입, 설계도

        // 변수 : 하나의 데이터를 저장할 수 있는 공간
        // 배열 : 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
        // 구조체 : 서로 관련된 여러 데이터(종류 관계X)를 하나로 저장할 수 있는 공간
        // 클래스 : 데이터와 함수의 결합(구조체 + 함수)

        // 사용자 정의 타입? 우리가 정의한 타입. 원하는 타입을 직접 만들 수 있다
        // 그 타입이 바로 클래스
        // 시간을 다루는 타입이 없어서 새로 만든다는 가정 => 기본형 8개 (자바에 시간을 다루기 위한 클래스가 있음)
        // 비객체지향적 코드
        int hour;
        int minute;
        int second;
        // 만약 3개의 시간을 다루려면?
        int hour1, hour2, hour3;
        int minute1, minute2, minute3;
        int second1, second2, second3;
        // 더 많은 시간을 다루려면? 배열 사용용
        // 시,분,초가 하나의 시간인데 각각 시간, 분, 초로 따로 묶여있음
        int[] hourArr = new int[3];
        int[] minuteArr = new int[3];
        int[] secondArr = new int[3];
        // 이 문제를 해결하기 위해서 객체지향적 코드 사용
        class Time {
            int hour;
            int minute;
            int second;
        }
        // 위처럼 3개의 변수를 선언하는 대신에 하나의 객체를 생성하는 걸로 대신할 수 있음
        Time t = new Time();


        // 변수의 종류
        // 선언위치에 따라 종류가 3가지
        class Variables
        {
            // 클래스 영역 : 선언문만 가능 (변수 선언, 메서드 선언만 가능, 순서 상관 X)
            int iv; // 인스턴스 변수(instance variable)
            // static int cv; 클래스 변수(static변수, 공유변수) = static + iv

            // 메서드 선언 + 메서드 정의({}부분)
            void method()
            {
                // 메서드 영역 (
                int lv = 0; // 지역변수(local variable)
            }
        }
        // 변수 생성시기
        // iv : 인스턴스가 생성되었을 때
        // cv : 클래스가 메모리 올라갈 때 (객체 생성 안해도됨), 아무때나 사용가능
        // lv : 변수 선언문이 수행되었을 때

        // 참고
        // CPU는 HDD, SSD에 있는 Time.class 파일을 직접 못가져옴(CPU가 너무 빠름(속도차이))
        // 그래서 중간에 둔게 RAM(메모리)
        // 파일을 읽으려면 메모리에 올려야 하는데 이것을 로딩이라고 함
        // 메모리에 로딩이 다 된 다음에 CPU가 읽고 쓸 수 있음, CPU는 모든 작업을 RAM하고만 함
        // 작업이 끝나면 메모리에 있는 내용을 디스크에 씀. 이것을 SAVE. 작업 내용을 SAVE 하지 않고 컴퓨터를 종료하면 다 날라감

        // 클래스 변수와 인스턴스 변수
        // 포커 카드가 있는데 하트 7과 스페이드 4가 있다.
        // 각각의 카드가 객체. 숫자나 모양 같은 개별적인 값들 즉, 객체마다 다른 값들을 iv(인스턴스 변수)라고 한다.
        // 폭, 높이 등 객체마다 공통적으로 가지고 있는 값들을 cv(클래스 변수)라고 한다.

        class Card {
            String kind;
            int number;

            // static int width = 100;
            // static int height = 250;
        }
        // 사용방법
        Card cd = new Card();
        cd.kind = "Heart";
        cd.number = 300;

        // 사용은 가능하지만 사용하지말기(권장안함) - 참조변수
        // cd.width = 200;
        // cd.height = 300;
        // 이 방식으로 사용하기 - 클래스이름
        // Card.width = 200;
        // Card.height = 300;


        // 메서드
        // 장점
        // 코드 중복 줄일 수 있음, 관리 쉬움, 재사용성, 간결해서 이해하기 쉬움움        // 반환타입(출력) 메서드 이름 매개변수선언(입력)
        // 메서드는 클래스 안에 있어야하고 함수는 클래스 독립적
        // 메서드는 한 가지 기능만 수행하도록 작성 => 의미있는 단위로 나눠야 재사용성 높아짐
        class Test {
            int add(int x, int y) { // 선언부
                int result = x + y; // 구현부
                return result;      // 구현부부            }
            }
            int max(int a, int b) {
                if(a > b) { // 이 부분만 적으면 return 에러
                    return a;
                } else {
                    return b;
                }
            }
        }
        // void 메서드의 경우 return 생략가능 => 컴파일러가 자동으로 생성
        // 자동형변환이 이루어질 수 있는 타입들은 다 반환값으로 가능
        // int 의 경우 char, byte, short

        // 호출스택(call stack)
        // 메서드 수행에 필요한 메모리가 제공되는 공간
        // 메서드가 호출되면 호출스택에 메모리 할당. 종료되면 해제
        // 아래 있는 메서드가 위의 메서드를 호출한 것(맨위 메서드 하나만 실행 중. 나머지는 대기 상태)
        // 쓰레드마다 스택을 가지고 있음


        // 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다
        class Data { int x; }
        Data d = new Data(); // 객체 생성 => 메모리에 올라감 => 메모리 주소를 d에 담음(참조변수)
        d.x = 10; // 메모리 주소에 있는 x 변경
        System.out.println("main() : x = " + d.x);
        change(d.x);
        System.out.println("After change(d.x)");
        System.out.println("main() : x = " + d.x); // 메모리 주소에 있는 x 출력

        // 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.


   }
    static void change(int x){ // 기본형 매개변수라 읽기만 가능
        x = 1000; // lv(지역변수를 변경한 것)
        System.out.println("change() : x = " + x);
        // 끝나고 change는 call stack에서 사라짐
    }
}
