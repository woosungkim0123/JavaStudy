# StreamMain

## 개념

StreamMain: 데이터의 흐름

StreamMain API(Java): 데이터의 흐름을 처리하는데 사용되는 파이프라인. 즉, 연속된 데이터를 처리하는 연산들의 모임

## 특징

1. 컬렉션과 다르게 데이터를 저장하지 않는다.
2. 원본 데이터를 변경하지 않고, 연산 결과를 새로운 Stream에 반영함으로써 불변성을 유지합니다
3. Stream은 컨베이어 벨트처럼 데이터를 한 번만 처리하여 효율적으로 전달합니다.
4. 손쉽게 병렬 처리할 수 있다

## 구성

0개 이상의 중개 연산과 하나의 종료 연산으로 구성된다.

### 생성

- 데이터 소스에서 스트림으로 변환하는 단계
- 컬렉션, 배열, 숫자 범위, 일련의 값들, 파일 등으로 부터 스트림을 생성 할 수 있습니다.

### 중개 연산

- 여러 중개 연산들이 서로 연결되어 파이프라인을 구성하는 단계
- 중개 연산들은 새로운 스트림을 반환하기 때문에 서로 연결될 수 있습니다.
- fitler, map, limit, sorted 등이 있습니다.
- Lazy evaluation 으로 최종 연산을 수행하기 전까지는 어떠한 연산도 수행하지 않습니다.
- 중개 연산을 Stateless / Stateful 연산으로 구분할 수 있고 대부분은 Stateless지만 distinct나 sorted처럼 이전 소스 데이터를 참조해야 하는 연산은 Stateful 연산입니다.
 
### Lazy evaluation을 활용한 연산 최적화 방법

**루프 퓨전**

서로 다른 연산을 하나의 단일 루프에서 처리하는 것처럼 병합하는 기법

**쇼트 서킷**

결과가 확실한 경우 뒤의 연산을 수행하지 않고 결과를 반환하는 기법 (&&연산에서 처음 표현식이 거짓이면 나머지 표현식을 평가하지 않는 것과 같은 예시)

```java
List<String> list = StreamMain.of("a", "ab", "d_oop", "abcd", "abcde")
        // 루프 퓨전: filter, map
        .filter(s -> {
            System.out.println("filter: " + s);
            return s.lenght() >= 2;
        })
        .map(s -> {
            System.out.println("map: " + s);
            return s.toUpperCase();
        })
        .limit(2) // 쇼트 서킷
        .collect(Collectors.toList());
```

### 종료 연산

- 스트림의 요소를 소비하여 파이프라인을 실행하고 결과를 도출하는 단계
- collect, forEach, reduce, allMatch, nonMatch, findFirst, findAny 등이 있습니다. (allMatch, nonMatch, findFirst, findAny 연산은 쇼트 서킷 연산이 적용될 수 있습니다.)
- 최종 연산한 스트림은 재사용할 수 없습니다.

## 장 단점

### 장점

1. 선언형으로 코드를 구현할 수 있음
    - 간결하고 가독성 향상, 메서드 체이닝 방식으로 연산의 목적과 순서를 명확히 표현할 수 있음 
    - 내부 반복 사용, 반복 로직은 개발자가 신경쓸 필요없이 어떤 작업을 부여할 것인지 선언적으로 표현하기만 하면됨 
    - 변하는 요구사항에 맞춰 쉽게 대응 가능

2. 병렬처리가 쉬워짐

### 단점

1. 내부적으로 많은 동작과 중간연산의 Lazy evaluation 때문에 상대적으로 디버깅이 어려움

2. for loop에 비해 성능이 떨어질 수 있음(원시 타입의 경우 15배, 래퍼 클래스의 경우나 루프 내에 연산 비용이 큰 경우 큰 성능 차이를 보이지 않음)

## 병렬 처리

- parallelStream을 사용하여 데이터를 병렬로 처리하여 성능을 향상 시킬 수 있습니다. 이때 내부적으로 ForkJoinPool을 사용해 큰 작업을 작은 작업으로 분할(Fork)하고 이들을 병렬로 처리한 후 결과를 합칩(Join)니다. (parallelStream()은 SplitIterator 인터페이스를 사용하여 스트림을 쪼개서 병렬 처리합니다.)
- 병렬 Stream에서 toList()와 같이 순서를 보장하는 Collector를 사용하면 최종 결과는 원본 데이터의 순서를 유지합니다. 반면, 순서가 보장되지 않는 toSet()와 같은 Collector를 사용하면 최종 결과의 순서가 무작위가 될 수 있습니다.
- 모든 경우에 병렬 스트림이 성능을 향상시키는 것은 아닙니다. 스레드 생성 및 관리, 컨텍스트 스위칭의 오버헤드 때문에 단일 스레드 처리보다 느려질 수 있습니다. 특히, 데이터가 방대하지 않은 경우에는 병렬 처리의 이점이 크지 않습니다.
- 병렬 처리의 한계 때문에 리액티브 프로그래밍과 리액티브 스트림이 등장했습니다. 이는 비동기 처리와 스레드 사용의 효율성을 높이는 방식으로 데이터 스트림을 처리합니다.