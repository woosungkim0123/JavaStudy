# 어노테이션

어노테이션은 클래스와 메서드에 추가하여 다양한 기능을 부여하는 역할을 합니다.

## @Retention

애노테이션의 라이프 사이클 즉, 애노테이션이 언제까지 살아 남아 있을지를 정하는 것입니다.

속성으로 RetentionPolicy를 받으며, RetentionPolicy는 다음과 같은 세 가지 옵션을 가집니다.

### RetentionPolicy.SOURCE

소스(.java) 파일까지만 유지되며, 컴파일 이후에는 사라집니다. 예시로 롬복의 @Getter, @Setter 등을 들 수 있습니다. 

롬복이 바이트코드를 생성해서 넣어주기 때문에 바이트코드에서는 어노테이션 정보가 필요없습니다. 그래서 컴파일 이후에 사라지는 SOURCE 옵션을 사용한 것입니다.

### RetentionPolicy.CLASS

컴파일된 바이트 코드(.class)까지 유지되며, 런타임 시에는 사라집니다. 예시로 롬복의 @NonNull 등을 들 수 있습니다. 

왜 SOURCE가 아니라 CLASS 정책을 사용한 것일까요? 

Maven이나 Gradle로 다운받은 라이브러리들 즉, jar파일에는 소스가 포함되어있지 않고 class파일이 포함되어있습니다.
즉, class 파일만 존재하는 라이브러리 같은 경우에도 타입체커나 IDE 부가기능 등을 사용하려면 CLASS 정책을 사용해야합니다.

### RetentionPolicy.RUNTIME

런타임 시에도 유지되며, 리플렉션을 통해 런타임 시에도 어노테이션 정보를 얻을 수 있습니다. 예시로 스프링의 @Autowired 등을 들 수 있습니다.

스프링이 올라오는 실행 시점에 컴포넌트 스캔이 가능해야하기 때문에 RUNTIME 정책을 사용한 것입니다.

## @Target

애노테이션이 적용할 위치를 지정하는 것입니다. java 8에서는 TypeParameter, TypeUse 등이 추가되었습니다.

TypeParameter는 타입 변수 선언문에 사용되며, TypeUse는 타입이 사용되는 모든 곳에 사용됩니다.

## @Repeatable

Java 8에서 추가되었고 애노테이션을 반복해서 사용할 수 있게 해줍니다.

중복 사용할 애노테이션을 컨테이너 애노테이션으로 감싸주고, @Repeatable에 컨테이너 애노테이션의 class를 넣어주면 됩니다.

### 주의할 점

- 컨테이너 애노테이션은 반드시 배열을 반환하는 value() 메서드를 가지고 있어야 합니다.

- 컨테이너 애노테이션에는 반드시 반복해서 사용할 애노테이션의 Retencion 정책과 Target 보다 더 넓은 범위의 Retencion 정책과 Target을 가져야 합니다.